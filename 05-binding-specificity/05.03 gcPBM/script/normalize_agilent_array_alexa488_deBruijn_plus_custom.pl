#!/usr/bin/perl
use strict;
use warnings;

#use lib '/nfs/labs/gordanlab/PBM_analysis/modules/';
#use lib '/nfs/gordan_sata/gordanlab/PBM_analysis/modules/';
use lib './modules/';

use analyze_agilent;

###########################################################
###
### normalize_agilent_array.pl
### Normalize and spatially detrend single subgrid of 4x44K
###   or 8x15K or 8x60k array
###
### M. Berger, 12/12/2006
###   modified 2/10/2007
###   modified 7/5/2007
###   modified 4/3/2008
### R. Gordan 02/02/2012 modified to take Fmedian instead of 
###   Fmedian-B whenever the column "ADJBSI" does not exist
###   (i.e. when masliner has not been run)
### R. Gordan 06/29/2013 modified to take 2x400k array
###
### Takes as input (1) an Alexa488 PBM GPR file (raw or
###   Masliner-adjusted), (2) optionally the Cy3 DNA
###   GPR file from the corresponding microarray subgrid, and
###   (3) the probe ID's and sequences, and outputs the following:
###
### (1) "Raw data" file
### 	Column 1: Column
### 	Column 2: Row
### 	Column 3: Spot Name
### 	Column 4: Spot ID
### 	Column 5: Sequence
### 	Column 6: Cy3 ADJBSI (if Cy3 not included, 1)
### 	Column 7: Cy3 Flags (if Cy3 not included, 0)
### 	Column 8: Alexa488 ADJBSI
### 	Column 9: Alexa488 Flags
### (Row 1 is a header. Data starts in row 2.)
###
### (2) "All data" file [same as above but with calculated values for
###     expected Cy3; obs/exp Cy3; normalized Alexa488; spatially-
###     adjusted Alexa488]
###
### (3) "deBruijn" file [ranked list of normalized intensities and
###	sequences of deBruijn 'all k-mer' probes, with control spots
###     removed. This can be used directly as input for k-mer scoring
###     and motif finding software.]
###
### (4) "Regression" file [results of linear regression over Cy3
###     probe intensities and sequences, including R^2 value indicating
###     quality of fit]
###
### Performs the following steps to normalize and
###    spatially detrend the signal on the array...
### Step 1: Calculate (Observed/Expected) Cy3
### Step 2: Normalize Alexa488 by (Obs/Exp) Cy3
### Step 3: Spatially adjust normalized PBM
###
### Array format (4x44K or 8x15K) is inferred from the sequence file
###
############################################################

### 02/02/12 RG: changed "F1 Median - B1" to "F488 Median" or "F594 Median" in the text below
### (I think the previous version of GenePix was outputting F1 instead of F488 or F594)

if ($#ARGV<5) {die "
#########################################################################################################
#
# USAGE: perl normalize_agilent_array.pl -i PBM_file -c CY3_file(optional) -s SEQUENCE_file -o OUTPUT_prefix
#
#
# -i PBM_file: .GPR file from GenePix (either exact output or adjusted by Masliner)
#       If generated by Masliner, will use the column labeled 'ADJBSI'.
#       Otherwise, should have a column labeled 'F488 Median'.
#
# -c CY3_file(optional): .GPR file from GenePix (either exact output or adjusted by Masliner)
#       If generated by Masliner, will use the column labeled 'ADJBSI'.
#       Otherwise, should have a column labeled 'F594 Median'.
#		NOTE: only probes with IDs 'dBrâ€¦' will be used for Cy3 regression!!!
#             only probes with IDs 'dBr...' or 'Ctrl...' will be adjusted!!!
#
#	**If this file is not included, only spatial detrending (not Cy3 normalization) will be performed.
#
# -s SEQUENCE_file: Text file containing probe sequences and coordinates for the corresponding array design
#       Contains five columns (with header): Column / Row / Probe Name / Probe ID / Sequence
#
# -o OUTPUT_prefix: Prefix for output filenames
#       If priting files to a subdirectory, the subdirectory must already exist
#
# EXAMPLE: perl normalize_agilent_array.pl -i pbm.gpr -c cy3.gpr -s 4x44k_v1_sequences.txt -o ./prot_name
#
# Will output the following files: (1) ./prot_name_rawdata.txt
#                                  (2) ./prot_name_alldata.txt
#                                  (3) ./prot_name_deBruijn.txt
#                                  (4) ./prot_name_regression.txt
#
#########################################################################################################

";}

############################################################
## 'Wavelength' numerical values from GenePix software
##    Should match column in GPR file labeled 'F Median'
############################################################
my $cy3_gp = 532; # Updated RG 02/02/2012
my $pbm_gp = 488; # Updated RG 02/02/2012
############################################################

my $array_type;
my $PBM_input_file;
my $Cy3_input_file;
my $sequence_file_name;
my $output_prefix;

while(@ARGV) {
    $_ = shift;
    if ($_ eq "-i") {$PBM_input_file = shift; next;}
    if ($_ eq "-c") {$Cy3_input_file = shift; next;}
    if ($_ eq "-s") {$sequence_file_name = shift; next;}
    if ($_ eq "-o") {$output_prefix = shift; next;}
}

#################################################
### Read in PBM, Cy3 information for each protein
#################################################

my @data_matrix;
my $col; my $row;
my %intensity;

open (FH1, "<$sequence_file_name") or die "Cannot open sequence file";
my $topline = <FH1>;
while (my $newline = <FH1>) {
    chomp $newline;
    my @entry = split /\t/, $newline;
    $col = $entry[0]; ### Column
    $row = $entry[1]; ### Row
    $data_matrix[$col][$row][0] = $entry[2]; ### Probe Name
    $data_matrix[$col][$row][1] = $entry[3]; ### Probe ID
    $data_matrix[$col][$row][2] = $entry[4]; ### Sequence
}
close (FH1);
my $last_column = $col;
my $last_row = $row;

if ($last_column == 266 && $last_row == 170) {
    $array_type = "4x44k";
    print "Array format recognized as '4x44K'.\n";
}
elsif ($last_column == 96 && $last_row == 164) {
    $array_type = "8x15k";
    print "Array format recognized as '8x15K'.\n";
}
elsif ($last_column == 192 && $last_row == 328) {
    $array_type = "8x60k";
    print "Array format recognized as '8x60K'.\n";
}
elsif ($last_column == 532 && $last_row == 340) {
   $array_type = "4x180k";
   print "Array format recognized as '4x180K'.\n";
}
elsif ($last_column == 528 && $last_row == 796) {
   $array_type = "2x400k";
   print "Array format recognized as '2x400K'.\n";
}
else {die "Cannot recognize array format as either '4x44K' or '8x15K' or '8x60K' or '4x180K' or '2x400K'";}

print "Reading Input File \"$PBM_input_file\".\n";

my $spotcheck = 0;
my $flag_col = 0;
my $adjbsi_col = 0;
my $bsi_col = 0;

open (FH2, "<$PBM_input_file") or die "Cannot open $PBM_input_file";	
while (my $line = <FH2>) {
    chomp $line;
    my @line = split /\t/, $line;
    if ($spotcheck == 1 && $line[1]) {
		$col = $line[1];
		$row = $line[2];
		$data_matrix[$col][$row][3] = 1; ### Cy3 BSI default (overwrite later)
		$data_matrix[$col][$row][4] = 0; ### Cy3 Flags default (overwrite later)
		if ($adjbsi_col>0) {$data_matrix[$col][$row][5] = $line[$adjbsi_col];} ### Alexa488 ADJBSI
		else {$data_matrix[$col][$row][5] = $line[$bsi_col];} ### Alexa488 BSI
		$data_matrix[$col][$row][6] = $line[$flag_col]; ### Alexa488 Flags
    }
    if ($line[0] =~ "Block") {
		$spotcheck=1;
		for (my $tally=0; $tally<=$#line; $tally++) {
			# Determine which columns are "Flags", "ADJBSI", and "F488 median"
		    if ($line[$tally] eq "Flags" || $line[$tally] eq "\"Flags\"") {$flag_col = $tally;}
		    if ($line[$tally] eq "ADJBSI" || $line[$tally] eq "\"ADJBSI\"") {$adjbsi_col = $tally;}
		    ### if ($line[$tally] eq "F$pbm_gp Median - B$pbm_gp" || $line[$tally] eq "\"F$pbm_gp Median - B$pbm_gp\"") {$bsi_col = $tally;} 
		    ### Modified RG 02/02/2012
		    if ($line[$tally] eq "F$pbm_gp Median" || $line[$tally] eq "\"F$pbm_gp Median\"") {$bsi_col = $tally;}
		}
		if ($flag_col<1) {die "Unable to find 'Flags' column in $PBM_input_file";}
		###if ($adjbsi_col<1 && $bsi_col<1) {die "Unable to find column labeled 'ADJBSI' or 'F$pbm_gp Median - B$pbm_gp' in $PBM_input_file";}
		### Modified RG 02/02/2012
		if ($adjbsi_col<1 && $bsi_col<1) {die "Unable to find column labeled 'ADJBSI' or 'F$pbm_gp Median' in $PBM_input_file";}
    }
}
if ($col != $last_column || $row != $last_row) {die "Columns and rows are uneven between $sequence_file_name and $PBM_input_file";}
close (FH2);

$spotcheck = 0;
$flag_col = 0;
$adjbsi_col = 0;
$bsi_col = 0;

if ( $Cy3_input_file ) {
	open (FH3, "<$Cy3_input_file") or die "Cannot open $Cy3_input_file";
	while (my $line = <FH3>) {
	    chomp $line;
	    my @line = split /\t/, $line;
	    if ($spotcheck == 1 && $line[1]) {
			$col = $line[1];
			$row = $line[2];
			if ($adjbsi_col>0) {$data_matrix[$col][$row][3] = $line[$adjbsi_col];} ### Cy3 ADJBSI
			else {$data_matrix[$col][$row][3] = $line[$bsi_col];} ### Cy3 BSI
			$data_matrix[$col][$row][4] = $line[$flag_col]; ### Cy3 Flags
	    }
	    if ($line[0] =~ "Block") {
			$spotcheck=1;
			for (my $tally=0; $tally<=$#line; $tally++) {
			    if ($line[$tally] eq "Flags" || $line[$tally] eq "\"Flags\"") {$flag_col = $tally;}
			    if ($line[$tally] eq "ADJBSI" || $line[$tally] eq "\"ADJBSI\"") {$adjbsi_col = $tally;}
			    ###if ($line[$tally] eq "F$cy3_gp Median - B$cy3_gp" || $line[$tally] eq "\"F$cy3_gp Median - B$cy3_gp\"") {$bsi_col = $tally;}
			    ### Modified RG 02/02/2012
			    if ($line[$tally] eq "F$cy3_gp Median" || $line[$tally] eq "\"F$cy3_gp Median\"") {$bsi_col = $tally;}
			}
			if ($flag_col<1) {die "Unable to find 'Flags' column in $Cy3_input_file";}
			###if ($bsi_col<1 && $adjbsi_col<1) {die "Unable to find column labeled 'ADJBSI' or 'F$cy3_gp Median - B$cy3_gp' in $Cy3_input_file";}
			### Modified RG 02/02/2012
			if ($bsi_col<1 && $adjbsi_col<1) {die "Unable to find column labeled 'ADJBSI' or 'F$cy3_gp Median' in $Cy3_input_file";}
		    }
	}
	if ($col != $last_column || $row != $last_row) {die "Columns and rows are uneven between $sequence_file_name and $Cy3_input_file";}
	close (FH3);
}

my $final_index = 6;

###################################################
### STEP 1: COMPUTE REGRESSION COEFFICIENTS FOR CY3
###################################################

### Use deBruijn (unflagged) spots to calculate regression coeffecients:
###   intercept, AAAA, AAAC, AAAG, AAAT, ..., ATTT

my $regressionorder = 3;
my $regressionoutput = $output_prefix."_regression.txt";

if ($Cy3_input_file) {
    print "Computing Expected Cy3 Signals. 4^$regressionorder Parameters.\n";
    $final_index = cy3_regression(\@data_matrix, $regressionorder, $array_type, $regressionoutput, $final_index);
}
else {
    for ($row=1; $row<=$last_row; $row++) {
		for ($col=1; $col<=$last_column; $col++) {
		    $data_matrix[$col][$row][$final_index+1]=1;
		    $data_matrix[$col][$row][$final_index+2]=1;
		}
    }
    $final_index = $final_index+2;
}

### Appends expected Cy3 intensity to data matrix.
### Calculates (Observed/Expected) Cy3 signal for all non-Agilent sequences.
### If no Cy3 normalization, appends (Observed/Expected) = 1.

###################################################
### STEP 2: NORMALIZE ALEXA488 BY CY3
###################################################

if ($Cy3_input_file) {
    print "Normalizing Alexa488 Intensities by Cy3.\n";
}
else {
	print "NOT normalizing Alexa488 Intensities by Cy3.\n";
}
my @norm_alexa488 = ();
$final_index = alexa488_normalize(\@data_matrix, \@norm_alexa488, $array_type, $final_index);

### Appends Cy3-normalized Alexa488 to data matrix.

my $Alexa488_median = median (\@norm_alexa488);
print "Overlall Alexa488_median: $Alexa488_median\n";
#print scalar(@norm_alexa488),"\n";
#print $norm_alexa488[0],"+\n";
#print $norm_alexa488[1],"+\n";
#print $norm_alexa488[2],"+\n";
#print $norm_alexa488[3],"+\n";


###################################################
### STEP 3: ADJUST ALEXA488 BY LOCATION ON ARRAY
###################################################

### Calculate median neighborhood (block radius R) for each spot.

my $radius = 7;

print "Calculating Neighborhood Median for Alexa488. Radius = $radius.\n";

$final_index = median_neighborhood(\@data_matrix,$radius,"Alexa488",$array_type,$Alexa488_median,$final_index);
#print "Final index: $final_index\n";
### Appends block median to data matrix.
### For Alexa488, divides by block median and multiplies by array median.



###################################################
### PRINT RESULTS TO OUTPUT FILES
###################################################

my $output1 = $output_prefix."_alldata.txt";
my $output2 = $output_prefix."_deBruijn.txt";
my $output3 = $output_prefix."_rawdata.txt";
%intensity=();
my @sorted_spots=();

open(OUTPUT3,">$output3") || die "Couldn't open 'raw data' output file for $output_prefix\n";
open(OUTPUT1,">$output1") || die "Couldn't open 'all data' output file for $output_prefix\n";
print "Printing to output files for \"$output_prefix\".\n";

print OUTPUT1 "Column\tRow\tName\tID\tSequence\tCy3\tCy3Flags\tAlexa488\tAlexa488Flags\tCy3Exp\tObs/Exp\tAlexa488Norm\tAlexa488Median\tAlexa488Adjusted\n";
print OUTPUT3 "Column\tRow\tName\tID\tSequence\tCy3\tCy3Flags\tAlexa488\tAlexa488Flags\n";
for (my $j=1; $j<=$last_row; $j++) {
    for (my $k=1; $k<=$last_column; $k++) 
    {
		print OUTPUT1 "$k\t$j";
		print OUTPUT3 "$k\t$j";
		for (my $item=0; $item<=$final_index; $item++) {
			if (!$data_matrix[$k][$j][$item]) {$data_matrix[$k][$j][$item] = "";} # RG 03/16/2012: for the control regions, to avoid getting error "Use of uninitialized value in concatenation..."
		    print OUTPUT1 "\t$data_matrix[$k][$j][$item]";		    
		    if ($item<=6) {
				print OUTPUT3 "\t$data_matrix[$k][$j][$item]";
		    }
		}
		print OUTPUT1 "\n";
		print OUTPUT3 "\n";
		## RG 09/26/2018 if ($data_matrix[$k][$j][$final_index] ne "NA" && ($data_matrix[$k][$j][1]=~"dBr" || $data_matrix[$k][$j][1]=~"Ctrl" || $data_matrix[$k][$j][0]=~"Cbf1Pho4Tye7")) {# RG 03/16/2012: Cbf1Pho4Tye7 is only used for the custom Tye7 array
		if ($data_matrix[$k][$j][$final_index] ne "NA" && (($data_matrix[$k][$j][1]=~"dBr") || ($data_matrix[$k][$j][0]=~"All") || ($data_matrix[$k][$j][1]=~"Pho4or"))) {# so that only probes that are not masked (ne "NA) AND for which (the Probe ID starts with dBr) OR (Probe name starts with All) get written to the deBuijn file 
		    $intensity{$data_matrix[$k][$j][2]} = $data_matrix[$k][$j][$final_index];
		}
    }
}
close(OUTPUT1);
close(OUTPUT3);

#### MFB added 2/12/07

open(OUTPUT2,">$output2") || die "Couldn't open 'deBruijn' output file for $output_prefix\n";

@sorted_spots = sort by_intensity keys %intensity;
sub by_intensity { $intensity{$b} <=> $intensity{$a} }

for (my $tally=0; $tally<=$#sorted_spots; $tally++) {
    my $spot_sequence = $sorted_spots[$tally];
    print OUTPUT2 sprintf("%.2f",$intensity{$spot_sequence}),"\t$spot_sequence\n";
}
close(OUTPUT2);
